#!/usr/bin/env python3
"""
Parts Links MCP Integration - Dixon Smart Repair
Simple MCP-based approach for generating retailer parts links
"""

import logging
import urllib.parse
from typing import Dict, List, Optional
from tavily_research import get_tavily_research_direct

logger = logging.getLogger(__name__)

def get_parts_links_mcp(part_name: str, vehicle_info: Optional[Dict] = None) -> str:
    """
    Generate retailer links using MCP Tavily search service
    
    Args:
        part_name: Name of the automotive part (e.g., "brake pads", "spark plugs")
        vehicle_info: Optional vehicle information for specific searches
        
    Returns:
        Formatted string with retailer links for chat display
    """
    try:
        logger.info(f"ðŸ”— Generating MCP-based parts links for: {part_name}")
        
        # Build search term with vehicle info if available
        search_term = build_search_term(part_name, vehicle_info)
        
        # Use Tavily MCP to search for retailer links
        retailer_links = search_retailers_with_tavily(search_term)
        
        # Generate fallback links for any missing retailers
        complete_links = ensure_all_retailers(retailer_links, search_term)
        
        # Format for chat display
        formatted_links = format_retailer_links(complete_links, part_name)
        
        logger.info(f"âœ… Generated retailer links for {part_name}")
        return formatted_links
        
    except Exception as e:
        logger.error(f"âŒ Error generating MCP parts links for {part_name}: {e}")
        return generate_fallback_links(part_name)

def build_search_term(part_name: str, vehicle_info: Optional[Dict]) -> str:
    """Build search term with vehicle specificity when available"""
    if not vehicle_info:
        return part_name
    
    year = vehicle_info.get('year', '')
    make = vehicle_info.get('make', '')
    model = vehicle_info.get('model', '')
    
    if year and make and model:
        return f"{year} {make} {model} {part_name}"
    elif make and model:
        return f"{make} {model} {part_name}"
    else:
        return part_name

def search_retailers_with_tavily(search_term: str) -> Dict[str, str]:
    """Use Tavily MCP service to search for retailer links"""
    try:
        # Search specifically on automotive retailer domains
        search_query = f"{search_term} buy online automotive parts"
        
        logger.info(f"ðŸ” Tavily MCP search: {search_query}")
        
        # Use Tavily with specific automotive retailer domains
        research_data = get_tavily_research_direct(
            query=search_query,
            domains=["autozone.com", "oreillyauto.com", "napaonline.com", 
                    "advanceautoparts.com", "rockauto.com", "amazon.com"],
            max_results=10
        )
        
        # Extract retailer links from results
        retailer_links = extract_retailer_links(research_data)
        
        logger.info(f"âœ… Found {len(retailer_links)} retailer links from Tavily MCP")
        return retailer_links
        
    except Exception as e:
        logger.warning(f"âš ï¸ Tavily MCP search failed: {e}")
        return {}

def extract_retailer_links(research_data: Dict) -> Dict[str, str]:
    """Extract retailer links from Tavily research results"""
    retailer_links = {}
    
    try:
        if not research_data or 'results' not in research_data:
            return retailer_links
        
        results = research_data.get('results', [])
        
        # Map domains to retailer names
        retailer_mapping = {
            'autozone.com': 'AutoZone',
            'oreillyauto.com': 'O\'Reilly',
            'napaonline.com': 'NAPA',
            'advanceautoparts.com': 'Advance',
            'rockauto.com': 'RockAuto',
            'amazon.com': 'Amazon'
        }
        
        for result in results:
            url = result.get('url', '')
            
            for domain, retailer_name in retailer_mapping.items():
                if domain in url and retailer_name not in retailer_links:
                    retailer_links[retailer_name] = url
                    break
        
        return retailer_links
        
    except Exception as e:
        logger.warning(f"âš ï¸ Error extracting retailer links: {e}")
        return {}

def ensure_all_retailers(found_links: Dict[str, str], search_term: str) -> Dict[str, str]:
    """Ensure all major retailers are represented with fallback search URLs"""
    
    # Priority retailer list for Seattle area
    all_retailers = ['AutoZone', 'O\'Reilly', 'NAPA', 'Advance', 'RockAuto', 'Amazon']
    
    complete_links = found_links.copy()
    encoded_term = urllib.parse.quote_plus(search_term)
    
    # Add fallback search URLs for missing retailers
    fallback_urls = {
        'AutoZone': f"https://www.autozone.com/search?searchText={encoded_term}",
        'O\'Reilly': f"https://www.oreillyauto.com/search?q={encoded_term}",
        'NAPA': f"https://www.napaonline.com/search?query={encoded_term}",
        'Advance': f"https://shop.advanceautoparts.com/find/?searchTerm={encoded_term}",
        'RockAuto': f"https://www.rockauto.com/en/catalog/{encoded_term}",
        'Amazon': f"https://www.amazon.com/s?k={encoded_term}+automotive"
    }
    
    for retailer in all_retailers:
        if retailer not in complete_links:
            complete_links[retailer] = fallback_urls[retailer]
    
    return complete_links

def format_retailer_links(links: Dict[str, str], part_name: str) -> str:
    """Format retailer links for chat display"""
    if not links:
        return f"ðŸ”— **Shop {part_name.title()}**: Search major auto parts retailers"
    
    # Create clickable links in priority order
    retailer_order = ['AutoZone', 'O\'Reilly', 'NAPA', 'Advance', 'RockAuto', 'Amazon']
    link_parts = []
    
    for retailer in retailer_order:
        if retailer in links:
            link_parts.append(f"[{retailer}]({links[retailer]})")
    
    # Format for chat display
    links_text = " | ".join(link_parts)
    return f"ðŸ”— **Shop {part_name.title()}**: {links_text}"

def generate_fallback_links(part_name: str) -> str:
    """Generate basic fallback links when MCP search fails"""
    encoded_term = urllib.parse.quote_plus(part_name)
    
    basic_links = [
        f"[AutoZone](https://www.autozone.com/search?searchText={encoded_term})",
        f"[O'Reilly](https://www.oreillyauto.com/search?q={encoded_term})",
        f"[NAPA](https://www.napaonline.com/search?query={encoded_term})",
        f"[Advance](https://shop.advanceautoparts.com/find/?searchTerm={encoded_term})",
        f"[RockAuto](https://www.rockauto.com/en/catalog/{encoded_term})",
        f"[Amazon](https://www.amazon.com/s?k={encoded_term}+automotive)"
    ]
    
    links_text = " | ".join(basic_links)
    return f"ðŸ”— **Shop {part_name.title()}**: {links_text}"
