#!/usr/bin/env python3
"""
Parts Links Utility - Dixon Smart Repair
Shared utility for generating retailer parts links across all automotive tools
"""

import logging
import urllib.parse
from typing import Dict, List, Optional, Any
from tavily_research import get_tavily_research_direct

logger = logging.getLogger(__name__)

def get_parts_links(part_name: str, vehicle_info: Optional[Dict] = None, search_enabled: bool = True) -> str:
    """
    Generate retailer links for automotive parts with Tavily search integration
    
    Args:
        part_name: Name of the automotive part (e.g., "brake pads", "spark plugs")
        vehicle_info: Optional vehicle information for specific searches
        search_enabled: Whether to perform Tavily search for real product links
        
    Returns:
        Formatted string with retailer links for chat display
    """
    try:
        logger.info(f"ðŸ”— Generating parts links for: {part_name}")
        
        # Build vehicle-specific search term if available
        search_term = build_vehicle_specific_search_term(part_name, vehicle_info)
        
        # Try Tavily search for real product links (if enabled)
        tavily_links = {}
        if search_enabled:
            tavily_links = search_parts_with_tavily(search_term, part_name)
        
        # Generate fallback retailer search URLs
        retailer_urls = generate_retailer_search_urls(search_term)
        
        # Combine Tavily results with fallback URLs
        final_links = combine_links(tavily_links, retailer_urls)
        
        # Format for chat display
        formatted_links = format_parts_links_for_chat(final_links, part_name)
        
        logger.info(f"âœ… Generated {len(final_links)} retailer links for {part_name}")
        return formatted_links
        
    except Exception as e:
        logger.error(f"âŒ Error generating parts links for {part_name}: {e}")
        # Return basic fallback links even if everything fails
        return generate_basic_fallback_links(part_name)

def build_vehicle_specific_search_term(part_name: str, vehicle_info: Optional[Dict]) -> str:
    """Build search term with vehicle specificity when available"""
    if not vehicle_info:
        return part_name
    
    # Extract vehicle details
    year = vehicle_info.get('year', '')
    make = vehicle_info.get('make', '')
    model = vehicle_info.get('model', '')
    
    # Build vehicle-specific search term
    if year and make and model:
        return f"{year} {make} {model} {part_name}"
    elif make and model:
        return f"{make} {model} {part_name}"
    elif make:
        return f"{make} {part_name}"
    else:
        return part_name

def search_parts_with_tavily(search_term: str, part_name: str) -> Dict[str, str]:
    """Use Tavily to search for actual product links"""
    try:
        # Search for parts on major automotive retailers
        search_query = f"{search_term} AutoZone O'Reilly NAPA Advance Auto Parts RockAuto buy online"
        
        logger.info(f"ðŸ” Tavily search for: {search_query}")
        
        # Get research data from Tavily
        research_data = get_tavily_research_direct(
            query=search_query,
            domains=["autozone.com", "oreillyauto.com", "napaonline.com", "advanceautoparts.com", "rockauto.com", "amazon.com"]
        )
        
        # Extract product links from research results
        product_links = extract_product_links_from_research(research_data)
        
        logger.info(f"âœ… Found {len(product_links)} product links from Tavily")
        return product_links
        
    except Exception as e:
        logger.warning(f"âš ï¸ Tavily search failed for {part_name}: {e}")
        return {}

def extract_product_links_from_research(research_data: Dict) -> Dict[str, str]:
    """Extract actual product links from Tavily research results"""
    product_links = {}
    
    try:
        if not research_data or 'results' not in research_data:
            return product_links
        
        results = research_data.get('results', [])
        
        for result in results:
            url = result.get('url', '')
            title = result.get('title', '')
            
            # Map domains to retailer names
            if 'autozone.com' in url and 'AutoZone' not in product_links:
                product_links['AutoZone'] = url
            elif 'oreillyauto.com' in url and 'O\'Reilly' not in product_links:
                product_links['O\'Reilly'] = url
            elif 'napaonline.com' in url and 'NAPA' not in product_links:
                product_links['NAPA'] = url
            elif 'advanceautoparts.com' in url and 'Advance' not in product_links:
                product_links['Advance'] = url
            elif 'rockauto.com' in url and 'RockAuto' not in product_links:
                product_links['RockAuto'] = url
            elif 'amazon.com' in url and 'Amazon' not in product_links:
                product_links['Amazon'] = url
        
        return product_links
        
    except Exception as e:
        logger.warning(f"âš ï¸ Error extracting product links: {e}")
        return {}

def generate_retailer_search_urls(search_term: str) -> Dict[str, str]:
    """Generate search URLs for all major automotive retailers"""
    encoded_term = urllib.parse.quote_plus(search_term)
    
    retailer_urls = {
        'AutoZone': f"https://www.autozone.com/search?searchText={encoded_term}",
        'O\'Reilly': f"https://www.oreillyauto.com/search?q={encoded_term}",
        'NAPA': f"https://www.napaonline.com/search?query={encoded_term}",
        'Advance': f"https://shop.advanceautoparts.com/find/?searchTerm={encoded_term}",
        'RockAuto': f"https://www.rockauto.com/en/catalog/{encoded_term}",
        'Amazon': f"https://www.amazon.com/s?k={encoded_term}+automotive"
    }
    
    return retailer_urls

def combine_links(tavily_links: Dict[str, str], fallback_urls: Dict[str, str]) -> Dict[str, str]:
    """Combine Tavily product links with fallback search URLs"""
    final_links = {}
    
    # Priority order for retailers
    retailer_order = ['AutoZone', 'O\'Reilly', 'NAPA', 'Advance', 'RockAuto', 'Amazon']
    
    for retailer in retailer_order:
        if retailer in tavily_links:
            # Use actual product link from Tavily
            final_links[retailer] = tavily_links[retailer]
        elif retailer in fallback_urls:
            # Use fallback search URL
            final_links[retailer] = fallback_urls[retailer]
    
    return final_links

def format_parts_links_for_chat(links: Dict[str, str], part_name: str) -> str:
    """Format retailer links for chat display"""
    if not links:
        return f"ðŸ”— **Shop {part_name.title()}**: Search major auto parts retailers"
    
    # Create clickable links
    link_parts = []
    for retailer, url in links.items():
        link_parts.append(f"[{retailer}]({url})")
    
    # Format for chat display
    links_text = " | ".join(link_parts)
    return f"ðŸ”— **Shop {part_name.title()}**: {links_text}"

def generate_basic_fallback_links(part_name: str) -> str:
    """Generate basic fallback links when everything else fails"""
    encoded_term = urllib.parse.quote_plus(part_name)
    
    basic_links = [
        f"[AutoZone](https://www.autozone.com/search?searchText={encoded_term})",
        f"[O'Reilly](https://www.oreillyauto.com/search?q={encoded_term})",
        f"[NAPA](https://www.napaonline.com/search?query={encoded_term})"
    ]
    
    links_text = " | ".join(basic_links)
    return f"ðŸ”— **Shop {part_name.title()}**: {links_text}"

def extract_part_names_from_diagnosis(potential_causes: List[Dict]) -> List[str]:
    """Extract part names from diagnosis causes for link generation"""
    part_names = []
    
    # Common automotive part patterns
    part_patterns = {
        'brake pad': ['brake pad', 'brake pads'],
        'brake rotor': ['brake rotor', 'brake rotors', 'rotor'],
        'air filter': ['air filter'],
        'spark plug': ['spark plug', 'spark plugs'],
        'battery': ['battery'],
        'alternator': ['alternator'],
        'starter': ['starter', 'starter motor'],
        'fuel filter': ['fuel filter'],
        'oil filter': ['oil filter'],
        'brake fluid': ['brake fluid'],
        'transmission fluid': ['transmission fluid'],
        'coolant': ['coolant', 'antifreeze']
    }
    
    for cause in potential_causes:
        cause_text = cause.get('cause', '').lower()
        
        for part_key, variations in part_patterns.items():
            if any(variation in cause_text for variation in variations):
                if part_key not in part_names:
                    part_names.append(part_key)
                break
    
    return part_names
